<script>
    Vue.component('video-pane', {
            template: '#video-pane',
            props: ['segment', 'scale'],
            data() {
                return {
                    framesManager: this.$store.state.framesManager,
                    annotatedObjectsTracker: null,
                    mouse: {
                        x: 0,
                        y: 0,
                        startX: 0,
                        startY: 0
                    },
                    framesRange: {
                        first: 0,
                        last: 0
                    },
                    originalDimensions: {
                        width: 0,
                        height: 0
                    },
                    currentDimensions: {
                        width: 0,
                        height: 0
                    },
                    tempAnnotatedObject: null,
                    currentState: '',
                    currentTime: 0,
                    firstFrame: 0,
                    lastFrame: 0,
                    currentFrame: 0,
                    currentScale: 0.5,
                    isPlaying: false,
                    isReady: false,
                    timeout: null,
                    ctx: null,
                    config: {
                        // Should be higher than real FPS to not skip real frames
                        // Hardcoded due to JS limitations
                        fps: 30,

                        // Low rate decreases the chance of losing frames with poor browser performances
                        playbackRate: 0.4,

                        // Format of the extracted frames
                        imageMimeType: 'image/jpeg',
                        imageExtension: '.jpg',

                        // Name of the extracted frames zip archive
                        framesZipFilename: 'extracted-frames.zip'
                    }
                }
            },
            computed: {},
            created() {
                console.log('video segment = ' + this.segment);
                this.$store.dispatch('objectsTrackerInit');
            },
            mounted() {
                this.ctx = this.$refs.canvas.getContext('2d');
                this.$store.watch(
                    (state, getters) => getters.currentFrame,
                    (currentFrame) => {
                        this.currentFrame = currentFrame;
                        if (this.isPlaying) {
                            this.drawFrame(currentFrame).then(() => {
                                this.timeout = setTimeout(() => this.nextFrame(), 1000 / (this.config.fps * parseFloat(this.config.playbackRate)));
                            });
                        } else {
                            let currentState = this.$store.state.currentState;
                            if (currentState != 'dragging') {
                                this.drawFrame(this.currentFrame);
                            }
                        }
                    }
                )
                this.$store.watch(
                    (state, getters) => getters.currentState,
                    (currentState) => {
                        console.log('changed state to ' + currentState)
                        if (currentState == 'playing') {
                            this.play();
                        }
                        if (currentState == 'paused') {
                            this.pause();
                        }
                    }
                )
                this.$store.watch(
                    (state, getters) => getters.currentObjectState,
                    (currentObjectState) => {
                        console.log('currentObjectState = ' + currentObjectState)
                        if ((currentObjectState == 'updated') || (currentObjectState == 'unselected')|| (currentObjectState == 'cleared')) {
                            this.drawFrame(this.currentFrame);
                        }
                    }
                )
                this.$store.watch(
                    (state, getters) => getters.idObjectSelected,
                    (idObjectSelected) => {
                        console.log('idObjectSelected = ' + idObjectSelected)
                        let currentObjectState = this.$store.state.currentObjectState;
                        if (currentObjectState == 'selected') {
                            this.drawFrame(this.currentFrame);
                        }
                    }
                )
                this.$store.watch(
                    (state, getters) => state.redrawFrame,
                    (redrawFrame) => {
                        if (redrawFrame) {
                            this.drawFrame(this.currentFrame);
                        }
                    }
                )
                this.currentState = this.$store.state.currentState;
                this.$store.watch(
                    (state, getters) => getters.currentState,
                    (currentState) => {
                        this.currentState = currentState;
                    }
                )

                this.$nextTick(() => {
                    this.extractionFileZip();
                });
            },
            methods: {
                clearAllAnnotatedObjects() {
                    this.$store.dispatch('objectsTrackerClearAll');
                },
                clearAnnotatedObject(i) {
                    this.$store.dispatch('clearAnnotatedObject', i);
                },
                addAnnotatedObjectControls(annotatedObject) {
                    console.log(annotatedObject);
                    annotatedObject.name = '';
                    annotatedObject.visible = true;
                    annotatedObject.hidden = false;
                    annotatedObject.locked = false;
                    annotatedObject.idFrame = -1;
                    annotatedObject.frame = '';
                    annotatedObject.idFE = -1;
                    annotatedObject.fe = '';
                    annotatedObject.color = 'white';
                    annotatedObject.startFrame = this.currentFrame;
                    annotatedObject.endFrame = this.currentFrame;
                    this.$store.dispatch('objectsTrackerAdd', annotatedObject);
                },
                initialize: function () {
                    this.currentFrame = 0;
                    this.isPlaying = false;
                    this.isReady = false;
                    this.clearAllAnnotatedObjects();
                    //this.$store.commit('currentState', 'paused');
                    this.$store.commit('currentState', 'loading');
                },
                ready: function () {
                    this.isReady = true;
                    //$('#btnPlay').linkbutton('enable');
                    //playButton.disabled = false;
                },

                seek: function (frameNumber) {
                    if (!this.isReady) {
                        return;
                    }
                    console.log('playre.seek = ' + frameNumber);

                    this.pause();

                    if (frameNumber >= 0 && frameNumber < framesManager.frames.totalFrames()) {
                        this.drawFrame(frameNumber);
                        this.currentFrame = frameNumber;
                    }
                },

                forward: function () {
                    this.seek(this.currentFrame + 1);
                },

                backward: function () {
                    this.seek(this.currentFrame - 1);
                },

                play: function () {
                    if (!this.isReady) {
                        return;
                    }
                    this.isPlaying = true;
                    this.$store.commit('currentState', 'playing');
                    this.nextFrame();
                },
                pause: function () {
                    if (!this.isReady) {
                        return;
                    }

                    this.isPlaying = false;
                    this.$store.commit('currentState', 'paused');
                    if (this.timeout != null) {
                        clearTimeout(this.timeout);
                        this.timeout = null;
                    }
                },
                toogle: function () {
                    if (!this.isPlaying) {
                        this.play();
                    } else {
                        this.pause();
                    }
                },
                nextFrame: function () {
                    if (!this.isPlaying) {
                        return;
                    }
                    if (this.currentFrame == this.lastFrame) {
                        this.done();
                        return;
                    }
                    this.currentFrame++;
                    this.$store.commit('currentFrame', this.currentFrame);
                },

                done: function () {
                    this.currentFrame = this.firstFrame;
                    this.isPlaying = false;
                    this.$store.commit('currentState', 'paused');
                },
                updateCurrentDimensions() {
                    this.currentDimensions = {
                        width: this.originalDimensions.width * this.currentScale,
                        height: this.originalDimensions.height * this.currentScale,
                    }
                },
                toAbsoluteCoord(x, y, width, height) {
                    return {
                        x: Math.round(x / this.currentScale),
                        y: Math.round(y / this.currentScale),
                        width: Math.round(width / this.currentScale),
                        height: Math.round(height / this.currentScale)
                    }
                },
                toScaledCoord(x, y, width, height) {
                    return {
                        x: Math.round(x * this.currentScale),
                        y: Math.round(y * this.currentScale),
                        width: Math.round(width * this.currentScale),
                        height: Math.round(height * this.currentScale)
                    }
                },
                drawFrame: function (frameNumber) {
                    let that = this;
                    return new Promise((resolve, _) => {
                        console.log('drawFrame ' + frameNumber);
                        let annotatedObjectsTracker = this.$store.getters.objectsTracker;
                        annotatedObjectsTracker.getFrameWithObjects(frameNumber).then((frameWithObjects) => {
                            let currentState = '';
                            let currentObject = that.$store.state.currentObject;
                            if (currentObject) {
                                currentState = that.$store.state.currentObjectState;
                            }
                            let img = frameWithObjects.img;
                            this.ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width * this.currentScale, img.height * this.currentScale);
                            //console.log(frameWithObjects);
                            for (let i = 0; i < frameWithObjects.objects.length; i++) {
                                let object = frameWithObjects.objects[i];
                                let annotatedObject = object.annotatedObject;
                                if (annotatedObject.hidden) {
                                    annotatedObject.dom.style.display = 'none';
                                } else {
                                    let annotatedFrame = object.annotatedFrame;
                                    if (annotatedFrame.isVisible()) {
                                        //if ((annotatedFrame.isVisible()) && (frameNumber >= annotatedObject.startFrame) && (frameNumber <= annotatedObject.endFrame)) {
                                        //console.log(annotatedFrame.blocked);
                                        let scaledBox = this.toScaledCoord(annotatedFrame.bbox.x, annotatedFrame.bbox.y, annotatedFrame.bbox.width, annotatedFrame.bbox.height);
                                        annotatedObject.dom.style.display = 'block';
                                        annotatedObject.dom.style.width = scaledBox.width + 'px';
                                        annotatedObject.dom.style.height = scaledBox.height + 'px';
                                        annotatedObject.dom.style.left = scaledBox.x + 'px';
                                        annotatedObject.dom.style.top = scaledBox.y + 'px';
                                        annotatedObject.dom.style.borderStyle = 'solid';
                                        annotatedObject.dom.style.borderColor = annotatedObject.color;
                                        annotatedObject.dom.style.backgroundColor = 'transparent';
                                        annotatedObject.dom.style.opacity = 1;
                                        annotatedObject.visible = true;
                                        if (currentObject) {
                                            if (annotatedObject.idObject == currentObject.idObject) {
                                                if (currentState == 'selected') {
                                                    annotatedObject.dom.style.backgroundColor = annotatedObject.color;
                                                    annotatedObject.dom.style.opacity = 0.5;
                                                }
                                            }
                                        }
                                        if (annotatedFrame.blocked) {
                                            annotatedObject.dom.style.opacity = 0.5;
                                            annotatedObject.dom.style.backgroundColor = 'white';
                                            annotatedObject.dom.style.borderStyle = 'dashed';
                                        }
                                    } else {
                                        annotatedObject.dom.style.display = 'none';
                                        annotatedObject.visible = false;
                                    }
                                }
                            }
                            that.$store.commit('redrawFrame', false);
                            resolve();
                        });
                    });
                },
                initializeCanvasDimensions: function () {
                    let doodle = this.$refs.doodle;
                    let canvas = this.$refs.canvas;
                    let videoPane = this.$refs.videoPaneContainer;
                    canvas.width = this.currentDimensions.width;
                    canvas.height = this.currentDimensions.height;
                    doodle.style.width = canvas.width + 'px';
                    doodle.style.height = canvas.height + 'px';
                    videoPaneContainer.style.width = canvas.width + 'px';
                },
                framesLoaded(firstFrame, lastFrame) {
                    console.log('Frames Loaded! ' + firstFrame + ' to ' + lastFrame);
                    this.framesRange = {
                        first: firstFrame,
                        last: lastFrame
                    }
                    this.$store.dispatch('updateFramesRange', this.framesRange);
                },
                extractionFileZip: function () {
                    this.$store.commit('currentState', 'loading');
                    this.initialize();
                    let promise;
                    let zip = null;
                    let url = this.$store.state.model.documentMM.framesPath + '/' + this.segment + '.zip';
                    console.log(url);
                    promise = extractFramesFromZipUrl(this.config, url, this.segment);
                    promise.then((frames) => {
                        const startTime = performance.now();

                        console.log(frames);
                        this.firstFrame = this.segment * 1000;
                        this.lastFrame = this.firstFrame + frames.totalFrames() - 1;
                        this.currentFrame = this.firstFrame;
                        if (frames.totalFrames() > 0) {
                            frames.getFrame(this.firstFrame).then((blob) => {
                                blobToImage(blob).then((img) => {
                                    this.originalDimensions = {
                                        width: img.width,
                                        height: img.height
                                    }
                                    this.updateCurrentDimensions();
                                    this.initializeCanvasDimensions();
                                    this.ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width * this.currentScale, img.height * this.currentScale);
                                    console.log('Video dimensions determined: ' + img.width + 'x' + img.height);
                                    this.framesManager.set(frames);
                                    console.log('pos framesManager');
                                    this.ready();
                                    this.framesLoaded(this.firstFrame, this.lastFrame);
                                    this.loadObjects();
                                    this.$store.commit('currentState', 'loaded');

                                });
                            });
                        }

                    });
                },

                loadObjects() {
                    let objectsLoaded = this.$store.state.model.objects;
                    let i = 0;
                    for(var object of objectsLoaded) {
                        if ((object.startFrame >= this.framesRange.first) && (object.startFrame <= this.framesRange.last)) {
                            let annotatedObject = new AnnotatedObject();
                            annotatedObject.idObject = i++;
                            annotatedObject.name = object.name;
                            annotatedObject.idFrame = object.idFrame ? parseInt(object.idFrame) : null;
                            annotatedObject.frame = object.frame;
                            annotatedObject.idFE = object.idFE ? parseInt(object.idFE) : null;
                            annotatedObject.fe = object.fe;
                            annotatedObject.color = object.idFE ?  '#' + object.color : 'white';
                            annotatedObject.hidden = false;
                            annotatedObject.locked = false;
                            annotatedObject.startFrame = parseInt(object.startFrame);
                            annotatedObject.endFrame = parseInt(object.endFrame);
                            annotatedObject.dom = this.newBboxElement();
                            this.$store.dispatch("objectsTrackerPush", annotatedObject);
                            this.interactify(
                                annotatedObject,
                                (x, y, width, height) => {
                                    //let bbox = new BoundingBox(x, y, width, height);
                                    console.log('annotated loaded object changing - box frame ' + this.currentFrame);
                                    console.log(x + ' ' + y + ' ' + width + ' ' + height);
                                    let absolute = this.toAbsoluteCoord(x, y, width, height);
                                    console.log(absolute);
                                    let bbox = new BoundingBox(absolute.x, absolute.y, absolute.width, absolute.height);
                                    annotatedObject.add(new AnnotatedFrame(this.currentFrame, bbox, true));
                                }
                            );

                            //addAnnotatedObjectControls(annotatedObject);

                            let lastFrame = -1;
                            let bbox = null;
                            let polygons = object.frames;
                            for (let j = 0; j < polygons.length; j++) {
                                let polygon = object.frames[j];
                                let frameNumber = parseInt(polygon.frameNumber);
                                let isGroundThrough = true;// parseInt(topLeft.find('l').text()) == 1;
                                let x = parseInt(polygon.x);
                                let y = parseInt(polygon.y);
                                let w = parseInt(polygon.width);
                                let h = parseInt(polygon.height);

                                /*
                                if (lastFrame + 1 != frameNumber) {
                                    let annotatedFrame = new AnnotatedFrame(lastFrame + 1, null, true);
                                    annotatedObject.add(annotatedFrame);
                                }

                                 */
                                if (lastFrame == -1) {
                                    while (lastFrame < frameNumber) {
                                        let annotatedFrame = new AnnotatedFrame(lastFrame + 1, bbox, false);
                                        annotatedObject.add(annotatedFrame);
                                        lastFrame++;
                                    }
                                }

                                bbox = new BoundingBox(x, y, w, h);
                                let annotatedFrame = new AnnotatedFrame(frameNumber, bbox, isGroundThrough);
                                annotatedFrame.blocked = (parseInt(polygon.blocked) == 1);
                                annotatedObject.add(annotatedFrame);

                                lastFrame = frameNumber;
                            }

                            /*
                            if (lastFrame + 1 < framesManager.frames.totalFrames()) {
                                let annotatedFrame = new AnnotatedFrame(lastFrame + 1, null, true);
                                annotatedObject.add(annotatedFrame);
                            }
                            */
                            lastFrame = annotatedObject.endFrame;
                            if ((lastFrame + 1) < this.framesRange.last) {
                                let annotatedFrame = new AnnotatedFrame(lastFrame + 1, null, true);
                                annotatedObject.add(annotatedFrame);
                            }
                            console.log(annotatedObject)

                        }
                    }
                    this.drawFrame(this.currentFrame);
                    this.$store.commit('objectsTrackerState', 'dirty');
                },

                newBboxElement() {
                    let dom = document.createElement('div');
                    dom.className = 'bbox';
                    this.$refs.doodle.appendChild(dom);
                    return dom;
                },
                interactify(annotatedObject, onChange) {

                    let that = this;

                    let dom = annotatedObject.dom;
                    let bbox = $(dom);
                    bbox.addClass('bbox');

                    let createHandleDiv = (className, content = null) => {
                        console.log('className = ' + className + '  content = ' + content);
                        let handle = document.createElement('div');
                        handle.className = className;
                        bbox.append(handle);
                        if (content !== null) {
                            handle.innerHTML = content;
                        }
                        return handle;
                    };

                    bbox.resizable({
                        handles: "n, e, s, w",
                        onStopResize: (e) => {
                            let position = bbox.position();
                            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
                        }
                    });

                    let x = createHandleDiv('handle center-drag');
                    let i = createHandleDiv('objectId', annotatedObject.idObject);
                    i.addEventListener("click", function() {
                        that.$store.dispatch('selectObject', parseInt(this.innerHTML))
                    });

                    bbox.draggable({
                        //containment: 'parent',
                        handle: $(x),
                        onDrag: (e) => {
                            var d = e.data;
                            if (d.left < 0) {
                                d.left = 0
                            }
                            if (d.top < 0) {
                                d.top = 0
                            }
                            if (d.left + $(d.target).outerWidth() > $(d.parent).width()) {
                                d.left = $(d.parent).width() - $(d.target).outerWidth();
                            }
                            if (d.top + $(d.target).outerHeight() > $(d.parent).height()) {
                                d.top = $(d.parent).height() - $(d.target).outerHeight();
                            }
                        },
                        //stop: (e, ui) => {
                        onStopDrag: (e) => {
                            let position = bbox.position();
                            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
                        }
                    });
                },

                onMouseMove(event) {
                    if (event.pageX) {
                        this.mouse.x = event.pageX;
                        this.mouse.y = event.pageY;
                    } else if (event.clientX) {
                        this.mouse.x = event.clientX;
                        this.mouse.y = event.clientY;
                    }
                    this.mouse.x -= this.$refs.doodle.offsetLeft;
                    this.mouse.y -= this.$refs.doodle.offsetTop;

                    if (this.tempAnnotatedObject !== null) {
                        this.tempAnnotatedObject.width = Math.abs(this.mouse.x - this.mouse.startX);
                        this.tempAnnotatedObject.height = Math.abs(this.mouse.y - this.mouse.startY);
                        this.tempAnnotatedObject.x = (this.mouse.x - this.mouse.startX < 0) ? this.mouse.x : this.mouse.startX;
                        this.tempAnnotatedObject.y = (this.mouse.y - this.mouse.startY < 0) ? this.mouse.y : this.mouse.startY;

                        this.tempAnnotatedObject.dom.style.width = this.tempAnnotatedObject.width + 'px';
                        this.tempAnnotatedObject.dom.style.height = this.tempAnnotatedObject.height + 'px';
                        this.tempAnnotatedObject.dom.style.left = this.tempAnnotatedObject.x + 'px';
                        this.tempAnnotatedObject.dom.style.top = this.tempAnnotatedObject.y + 'px';
                    }

                },
                onMouseClick(event) {
                    let doodle = this.$refs.doodle;
                    if (doodle.style.cursor != 'crosshair') {
                        return;
                    }

                    if (this.tempAnnotatedObject != null) {
                        let annotatedObject = new AnnotatedObject();
                        annotatedObject.dom = this.tempAnnotatedObject.dom;
                        let absolute = this.toAbsoluteCoord(this.tempAnnotatedObject.x, this.tempAnnotatedObject.y, this.tempAnnotatedObject.width, this.tempAnnotatedObject.height);
                        console.log(absolute);
                        let bbox = new BoundingBox(absolute.x, absolute.y, absolute.width, absolute.height);
                        annotatedObject.add(new AnnotatedFrame(this.currentFrame, bbox, true));
                        this.addAnnotatedObjectControls(annotatedObject);
                        this.tempAnnotatedObject = null;

                        this.interactify(
                            annotatedObject,
                            (x, y, width, height) => {
                                console.log('annotated object changing - box frame ' + this.currentFrame);
                                console.log(x + ' ' + y + ' ' + width + ' ' + height);
                                let absolute = this.toAbsoluteCoord(x, y, width, height);
                                console.log(absolute);
                                let bbox = new BoundingBox(absolute.x, absolute.y, absolute.width, absolute.height);
                                annotatedObject.add(new AnnotatedFrame(this.currentFrame, bbox, true));
                            }
                        );
                        doodle.style.cursor = 'default';
                    } else {
                        this.mouse.startX = this.mouse.x;
                        this.mouse.startY = this.mouse.y;
                        let dom = this.newBboxElement();
                        dom.style.left = this.mouse.x + 'px';
                        dom.style.top = this.mouse.y + 'px';
                        this.tempAnnotatedObject = {
                            dom: dom
                        };
                    }
                },
                onNewObjectClick(currentFrame) {
                    console.log('newObject');
                    this.$refs.doodle.style.cursor = 'crosshair';
                },
            },
            watch: {
                scale(value) {
                    console.log('change scale');
                    this.currentScale = value / 100;
                    this.updateCurrentDimensions();
                    this.initializeCanvasDimensions();
                    console.log(this.currentDimensions);
                    this.drawFrame(this.currentFrame);
                },
                segment(value) {
                    console.log('segment = ' + value);
                    this.extractionFileZip();
                },
            }
        }
    );
</script>

<script type="text/x-template" id="video-pane">
    <div  style="display:flex; flex-direction: row;padding-left: 16px; width:auto">
        <div ref="videoPaneContainer" id="videoPaneContainer">
            <div ref="doodle" id="doodle" @mousemove="onMouseMove" @click="onMouseClick">
                <div v-if="(currentState == 'loading')">Loading...</div>
                <canvas ref="canvas" id="canvas">
                </canvas>
            </div>
            <div v-if="(currentState != 'loading')" id="controlsPane" style="margin-bottom: 32px">
                <controls-pane></controls-pane>
            </div>
        </div>
        <div id="toolsPane">
            <tools-pane
                    v-on:newObjectClick="onNewObjectClick"
            ></tools-pane>
        </div>
    </div>
</script>


<script>
    Vue.component('video-pane', {
            template: '#video-pane',
            props: ['segment', 'scale', 'reDrawFrame'],
            data() {
                return {
                    framesManager: new FramesManager(),
                    annotatedObjectsTracker: null,
                    mouse: {
                        x: 0,
                        y: 0,
                        startX: 0,
                        startY: 0
                    },
                    framesRange: {
                        first: 0,
                        last: 0
                    },
                    originalDimensions: {
                        width: 0,
                        height: 0
                    },
                    currentDimensions: {
                        width: 0,
                        height: 0
                    },
                    tempAnnotatedObject: null,
                    currentTime: 0,
                    firstFrame: 0,
                    lastFrame: 0,
                    currentFrame: 0,
                    currentScale: 0.5,
                    isPlaying: false,
                    isReady: false,
                    timeout: null,
                    ctx: null,
                    config: {
                        // Should be higher than real FPS to not skip real frames
                        // Hardcoded due to JS limitations
                        fps: 30,

                        // Low rate decreases the chance of losing frames with poor browser performances
                        playbackRate: 0.4,

                        // Format of the extracted frames
                        imageMimeType: 'image/jpeg',
                        imageExtension: '.jpg',

                        // Name of the extracted frames zip archive
                        framesZipFilename: 'extracted-frames.zip'
                    }
                }
            },
            computed: {},
            created() {
                console.log('video segment = ' + this.segment);
                this.annotatedObjectsTracker = new AnnotatedObjectsTracker(this.framesManager)
            },
            mounted() {
                this.ctx = this.$refs.canvas.getContext('2d');
                this.$store.watch(
                    (state, getters) => getters.currentFrame,
                    (currentFrame) => {
                        this.currentFrame = currentFrame;
                        if (this.isPlaying) {
                            this.drawFrame(currentFrame).then(() => {
                                this.timeout = setTimeout(() => this.nextFrame(), 1000 / (this.config.fps * parseFloat(this.config.playbackRate)));
                            });
                        } else {
                            this.drawFrame(this.currentFrame);
                        }
                    }
                )
                this.$store.watch(
                    (state, getters) => getters.currentState,
                    (currentState) => {
                        console.log('changed state to ' + currentState)
                        if (currentState == 'playing') {
                            this.play();
                        }
                        if (currentState == 'paused') {
                            this.pause();
                        }
                    }
                )
                this.extractionFileZip();
            },
            methods: {
                clearAllAnnotatedObjects() {
                    for (let i = 0; i < this.annotatedObjectsTracker.annotatedObjects.length; i++) {
                        this.clearAnnotatedObject(i);
                    }
                },
                clearAnnotatedObject(i) {
                    let annotatedObject = this.annotatedObjectsTracker.annotatedObjects[i];
                    annotatedObject.controls.remove();
                    $(annotatedObject.dom).remove();
                    this.annotatedObjectsTracker.annotatedObjects.splice(i, 1);
                    //annotatedObjectsSet.remove(annotatedObject)
                },
                addAnnotatedObjectControls(annotatedObject) {
                    console.log(annotatedObject);
                    annotatedObject.name = '';
                    annotatedObject.visible = true;
                    annotatedObject.occlusion = false;
                    annotatedObject.hide = false;
                    annotatedObject.idFE = -1;
                    annotatedObject.fe = '';
                    annotatedObject.color = 'white';
                    annotatedObject.idObject = this.annotatedObjectsTracker.annotatedObjects.length;
                    this.annotatedObjectsTracker.annotatedObjects.push(annotatedObject);
                    //this.$emit('createdNewObject', this.annotatedObjectsTracker, annotatedObject);
                    this.$store.dispatch('setObjects', this.annotatedObjectsTracker.annotatedObjects);
                    this.$store.commit('currentObject',annotatedObject);
                    this.$store.commit('currentObjectState', 'created');
                    console.log('new Object');
                },
                initialize: function () {
                    this.currentFrame = 0;
                    this.isPlaying = false;
                    this.isReady = false;
                    this.clearAllAnnotatedObjects();
                    this.$store.commit('currentState', 'paused');
                },
                ready: function () {
                    this.isReady = true;
                    //$('#btnPlay').linkbutton('enable');
                    //playButton.disabled = false;
                },

                seek: function (frameNumber) {
                    if (!this.isReady) {
                        return;
                    }
                    console.log('playre.seek = ' + frameNumber);

                    this.pause();

                    if (frameNumber >= 0 && frameNumber < framesManager.frames.totalFrames()) {
                        this.drawFrame(frameNumber);
                        this.currentFrame = frameNumber;
                    }
                },

                forward: function () {
                    this.seek(this.currentFrame + 1);
                },

                backward: function () {
                    this.seek(this.currentFrame - 1);
                },

                play: function () {
                    if (!this.isReady) {
                        return;
                    }
                    this.isPlaying = true;
                    this.$store.commit('currentState', 'playing');
                    this.nextFrame();
                },
                pause: function () {
                    if (!this.isReady) {
                        return;
                    }

                    this.isPlaying = false;
                    this.$store.commit('currentState', 'paused');
                    if (this.timeout != null) {
                        clearTimeout(this.timeout);
                        this.timeout = null;
                    }
                },
                toogle: function () {
                    if (!this.isPlaying) {
                        this.play();
                    } else {
                        this.pause();
                    }
                },
                nextFrame: function () {
                    if (!this.isPlaying) {
                        return;
                    }
                    if (this.currentFrame == this.lastFrame) {
                        this.done();
                        return;
                    }
                    this.currentFrame++;
                    this.$store.commit('currentFrame', this.currentFrame);
                },

                done: function () {
                    this.currentFrame = this.firstFrame;
                    this.isPlaying = false;
                    this.$store.commit('currentState', 'paused');
                },
                updateCurrentDimensions() {
                    this.currentDimensions = {
                        width: this.originalDimensions.width * this.currentScale,
                        height: this.originalDimensions.height * this.currentScale,
                    }
                },
                toAbsoluteCoord(x, y, width, height) {
                    return {
                        x: Math.round(x / this.currentScale),
                        y: Math.round(y / this.currentScale),
                        width: Math.round(width / this.currentScale),
                        height: Math.round(height / this.currentScale)
                    }
                },
                toScaledCoord(x, y, width, height) {
                    return {
                        x: Math.round(x * this.currentScale),
                        y: Math.round(y * this.currentScale),
                        width: Math.round(width * this.currentScale),
                        height: Math.round(height * this.currentScale)
                    }
                },
                drawFrame: function (frameNumber) {
                    return new Promise((resolve, _) => {
                        console.log('drawFrame ' + frameNumber);
                        this.annotatedObjectsTracker.getFrameWithObjects(frameNumber).then((frameWithObjects) => {
                            let img = frameWithObjects.img;
                            this.ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width * this.currentScale, img.height * this.currentScale);
                            console.log(frameWithObjects);
                            for (let i = 0; i < frameWithObjects.objects.length; i++) {
                                let object = frameWithObjects.objects[i];
                                let annotatedObject = object.annotatedObject;
                                let annotatedFrame = object.annotatedFrame;
                                if (annotatedFrame.isVisible()) {
                                    let scaledBox = this.toScaledCoord(annotatedFrame.bbox.x, annotatedFrame.bbox.y, annotatedFrame.bbox.width, annotatedFrame.bbox.height);
                                    annotatedObject.dom.style.display = 'block';
                                    annotatedObject.dom.style.width = scaledBox.width + 'px';
                                    annotatedObject.dom.style.height = scaledBox.height + 'px';
                                    annotatedObject.dom.style.left = scaledBox.x + 'px';
                                    annotatedObject.dom.style.top = scaledBox.y + 'px';
                                    annotatedObject.dom.style.borderColor = annotatedObject.color;
                                    //annotatedObject.visible.prop('checked', true);
                                    annotatedObject.visible = true;
                                } else {
                                    annotatedObject.dom.style.display = 'none';
                                    annotatedObject.visible = false;
                                    //annotatedObject.visible.prop('checked', false);
                                }
                            }

                            /*
                            let shouldHideOthers = frameWithObjects.objects.some(o => o.annotatedObject.hideOthers);
                            if (shouldHideOthers) {
                                for (let i = 0; i < frameWithObjects.objects.length; i++) {
                                    let object = frameWithObjects.objects[i];
                                    let annotatedObject = object.annotatedObject;
                                    if (!annotatedObject.hideOthers) {
                                        annotatedObject.dom.style.display = 'none';
                                    }
                                }
                            }
                             */

                            resolve();
                        });
                    });
                },
                initializeCanvasDimensions: function () {
                    let doodle = this.$refs.doodle;
                    let canvas = this.$refs.canvas;
                    let videoPane = this.$refs.videoPaneContainer;
                    canvas.width = this.currentDimensions.width;
                    canvas.height = this.currentDimensions.height;
                    doodle.style.width = canvas.width + 'px';
                    doodle.style.height = canvas.height + 'px';
                    videoPaneContainer.style.width = canvas.width + 'px';
                },
                framesLoaded(firstFrame, lastFrame) {
                    console.log('Frames Loaded! ' + firstFrame + ' to ' + lastFrame);
                    this.framesRange = {
                        first: firstFrame,
                        last: lastFrame
                    }
                    this.$store.commit('framesRange', this.framesRange);
                },
                extractionFileZip: function () {
                    this.initialize();
                    let promise;
                    let zip = null;
                    let url = this.$store.state.model.documentMM.framesPath + '/' + this.segment + '.zip';
                    console.log(url);
                    promise = extractFramesFromZipUrl(this.config, url, this.segment);
                    promise.then((frames) => {
                        console.log(frames);
                        console.log('Extraction completed. ' + frames.totalFrames() + ' frames captured.');
                        this.firstFrame = this.segment * 1000;
                        this.lastFrame = this.firstFrame + frames.totalFrames() - 1;
                        this.currentFrame = this.firstFrame;
                        if (frames.totalFrames() > 0) {
                            frames.getFrame(this.firstFrame).then((blob) => {
                                blobToImage(blob).then((img) => {
                                    this.originalDimensions = {
                                        width: img.width,
                                        height: img.height
                                    }
                                    this.updateCurrentDimensions();
                                    this.initializeCanvasDimensions();
                                    this.ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width * this.currentScale, img.height * this.currentScale);
                                    console.log('Video dimensions determined: ' + img.width + 'x' + img.height);
                                    this.framesManager.set(frames);
                                    console.log('pos framesManager');
                                    this.ready();
                                    this.framesLoaded(this.firstFrame, this.lastFrame);
                                });
                            });
                        }
                    });
                },
                newBboxElement() {
                    let dom = document.createElement('div');
                    dom.className = 'bbox';
                    this.$refs.doodle.appendChild(dom);
                    console.log('new box');
                    console.log(dom);
                    return dom;
                },
                interactify(annotatedObject, onChange) {
                    let dom = annotatedObject.dom;
                    let bbox = $(dom);
                    bbox.addClass('bbox');

                    let createHandleDiv = (className, content = null) => {
                        console.log(content);
                        let handle = document.createElement('div');
                        handle.className = className;
                        bbox.append(handle);
                        if (content !== null) {
                            handle.innerHTML = content;
                        }
                        return handle;
                    };

                    bbox.resizable({
                        handles: "n, e, s, w",
                        onStopResize: (e) => {
                            let position = bbox.position();
                            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
                        }
                    });

                    let x = createHandleDiv('handle center-drag');
                    console.log(x);
                    let i = createHandleDiv('objectId', annotatedObject.idObject);


                    bbox.draggable({
                        //containment: 'parent',
                        handle: $(x),
                        onDrag: (e) => {
                            var d = e.data;
                            if (d.left < 0) {
                                d.left = 0
                            }
                            if (d.top < 0) {
                                d.top = 0
                            }
                            if (d.left + $(d.target).outerWidth() > $(d.parent).width()) {
                                d.left = $(d.parent).width() - $(d.target).outerWidth();
                            }
                            if (d.top + $(d.target).outerHeight() > $(d.parent).height()) {
                                d.top = $(d.parent).height() - $(d.target).outerHeight();
                            }
                        },
                        //stop: (e, ui) => {
                        onStopDrag: (e) => {
                            let position = bbox.position();
                            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
                        }
                    });
                },

                onMouseMove(event) {
                    if (event.pageX) {
                        this.mouse.x = event.pageX;
                        this.mouse.y = event.pageY;
                    } else if (event.clientX) {
                        this.mouse.x = event.clientX;
                        this.mouse.y = event.clientY;
                    }
                    this.mouse.x -= this.$refs.doodle.offsetLeft;
                    this.mouse.y -= this.$refs.doodle.offsetTop;

                    if (this.tempAnnotatedObject !== null) {
                        this.tempAnnotatedObject.width = Math.abs(this.mouse.x - this.mouse.startX);
                        this.tempAnnotatedObject.height = Math.abs(this.mouse.y - this.mouse.startY);
                        this.tempAnnotatedObject.x = (this.mouse.x - this.mouse.startX < 0) ? this.mouse.x : this.mouse.startX;
                        this.tempAnnotatedObject.y = (this.mouse.y - this.mouse.startY < 0) ? this.mouse.y : this.mouse.startY;

                        this.tempAnnotatedObject.dom.style.width = this.tempAnnotatedObject.width + 'px';
                        this.tempAnnotatedObject.dom.style.height = this.tempAnnotatedObject.height + 'px';
                        this.tempAnnotatedObject.dom.style.left = this.tempAnnotatedObject.x + 'px';
                        this.tempAnnotatedObject.dom.style.top = this.tempAnnotatedObject.y + 'px';
                    }

                },
                onMouseClick(event) {
                    let doodle = this.$refs.doodle;
                    if (doodle.style.cursor != 'crosshair') {
                        return;
                    }

                    if (this.tempAnnotatedObject != null) {
                        let annotatedObject = new AnnotatedObject();
                        annotatedObject.dom = this.tempAnnotatedObject.dom;
                        let absolute = this.toAbsoluteCoord(this.tempAnnotatedObject.x, this.tempAnnotatedObject.y, this.tempAnnotatedObject.width, this.tempAnnotatedObject.height);
                        console.log(absolute);
                        let bbox = new BoundingBox(absolute.x, absolute.y, absolute.width, absolute.height);
                        annotatedObject.add(new AnnotatedFrame(this.currentFrame, bbox, true));
                        this.addAnnotatedObjectControls(annotatedObject);
                        this.tempAnnotatedObject = null;

                        this.interactify(
                            annotatedObject,
                            (x, y, width, height) => {
                                console.log('annotated object changing - box frame ' + this.currentFrame);
                                console.log(x + ' ' + y + ' ' + width + ' ' + height);
                                let absolute = this.toAbsoluteCoord(x, y, width, height);
                                console.log(absolute);
                                let bbox = new BoundingBox(absolute.x, absolute.y, absolute.width, absolute.height);
                                annotatedObject.add(new AnnotatedFrame(this.currentFrame, bbox, true));
                            }
                        );
                        doodle.style.cursor = 'default';
                    } else {
                        this.mouse.startX = this.mouse.x;
                        this.mouse.startY = this.mouse.y;
                        let dom = this.newBboxElement();
                        dom.style.left = this.mouse.x + 'px';
                        dom.style.top = this.mouse.y + 'px';
                        this.tempAnnotatedObject = {
                            dom: dom
                        };
                    }
                },
                onNewObjectClick(currentFrame) {
                    console.log('newObject');
                    this.$refs.doodle.style.cursor = 'crosshair';
                },
            },
            watch: {
                scale(value) {
                    console.log('change scale');
                    this.currentScale = value / 100;
                    this.updateCurrentDimensions();
                    this.initializeCanvasDimensions();
                    console.log(this.currentDimensions);
                    this.drawFrame(this.currentFrame);
                },
                segment(value) {
                    console.log('segment = ' + value);
                    this.extractionFileZip();
                },
                reDrawFrame(value) {
                    console.log('reDrawFrame ' + value);
                    if (value) {
                        this.drawFrame(this.currentFrame);
                    }
                }
            }
        }
    );
</script>

<script type="text/x-template" id="video-pane">
    <div style="display:flex; flex-direction: row;padding-left: 16px; width:auto">
        <div ref="videoPaneContainer" id="videoPaneContainer">
            <div ref="doodle" id="doodle" @mousemove="onMouseMove" @click="onMouseClick">
                <canvas ref="canvas" id="canvas"></canvas>
            </div>
            <div id="controlsPane" style="margin-bottom: 32px">
                <controls-pane :framesRange="framesRange"></controls-pane>
            </div>
        </div>
        <div id="toolsPane" style="padding:8px">
            <tools-pane v-on:newObjectClick="onNewObjectClick"></tools-pane>
        </div>
    </div>
</script>

